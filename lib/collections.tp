import lang;

abstract class Iterator<T> {
    abstract fn hasNext() boolean;

    abstract fn next() *T;
}

abstract class Iterable<T> {
    abstract fn iter() *Iterator<T>;
}

class ArrayIterator<T>(Iterator<T>) {
    private array: T[];
    index: int = 0;

    fn __new__(array: T[]) void {
        this.array = array;
    }

    fn hasNext() boolean {
        return this.index < this.array.length;
    }

    fn next() *T {
        return this.array[this.index++];
    }
}

class IntArrayIterator {
    private array: int[];
    index: int = 0;

    fn __new__(array: int[]) void {
        this.array = array;
    }

    fn hasNext() boolean {
        return this.index < this.array.length;
    }

    fn next() int {
        return this.array[this.index++];
    }
}

abstract class Collection<T>(Iterable<T>) {
    abstract fn size() int;
}

abstract class AbsList<T>(Collection<T>) {
    abstract fn append(value: *T) void;

    abstract fn get(index: int) *T;
}

class ListIterator<T>(Iterator<T>) {
    private lst: *List<T>;
    index: int = 0;

    fn __new__(lst: *List<T>) void {
        this.lst = lst;
    }

    fn hasNext() boolean {
        return this.index < this.lst.size();
    }

    fn next() *T {
        return this.lst.get(this.index++);
    }
}

class List<T>(AbsList<T>) {
    private array: T[];
    size: int;

    fn __new__() void {
        super.__new__();

        this.array = new T[8];
    }

    fn iter() *ListIterator<T> {
        return new ListIterator<T>(this);
    }

    @Override
    fn size() int {
        return this.size;
    }

    @Override
    fn append(value: *T) void {
        this.array[this.size++] = value;

        this.checkSize();
    }

    @Override
    fn get(index: int) *T {
        return this.array[index];
    }

    @Override
    fn toString() *String {
        strArr := new String[this.size];
        for i := 0; i < this.size; i++ {
            strArr[i] = this.get(i).toString();
        }
        joint := ", ".join(strArr);
        return "[".concat(joint).concat("]");
    }

    protected fn checkSize() void {
        if this.size == this.array.length {
            this.expand();
        }
        if this.size < this.array.length / 4 {
            this.collapse();
        }
    }

    private fn expand() void {
        arr := new T[this.array.length * 2];
        arraycopy(this.array, 0, arr, 0, this.size);
        del this.array;
        this.array = arr;
    }

    private fn collapse() void {

    }
}

abstract class Map<K, V> {

}

class HashMap<K, V>(Map<K, V>) {

}

export {
    Iterator, ListIterator, ArrayIterator,
    AbsList, List,
    Map, HashMap,
}
