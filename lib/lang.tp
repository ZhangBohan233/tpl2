require {
    print_int, println_int,
    print_float, println_float,
    print_char, println_char,
    print_byte, println_byte,
    print_str, println_str,
    memory_segment
}

/*
Macro constants
*/
macro boolean {int}
const FALSE: int = 0;
const TRUE: int = 1;
const NULL: *void = 0 as *void;

class Object {
    fn __new__() void {
    }

    fn __del__() void {
    }

    fn hash() int {
        return this.__class__ * ((this as *void) as int);
    }

    fn equals(other: *Object) boolean {
        return this == other;
    }

    fn toString() *String {
        return "Object@";
    }
}

class String {
    private const chars: char[];

    fn __new__(chars: char[]) void {
        super.__new__();

        this.chars = chars;
    }

    fn __new__(other: *String) void {
        super.__new__();

        this.chars = other.chars;
    }

    fn __del__() void {
        if memory_segment(this.chars) == 3 {
            return;
        }
        del this.chars;

        super.__del__();
    }

    fn equals(other: *Object) boolean {
        if not (other instanceof String) {
            return FALSE;
        }
        os := other as *String;
        if this.length() != os.length() {
            return FALSE;
        }
        for i := 0; i < this.chars.length; i++ {
            if this.chars[i] != os.chars[i] {
                return FALSE;
            }
        }
        return TRUE;
    }

    fn length() int {
        return this.chars.length;
    }

    fn print() void {
        print_str(this.chars);
    }

    fn println() void {
        println_str(this.chars);
    }
}

abstract class Number {
    fn __new__() void {
        super.__new__();
    }

    abstract fn intValue() int;
}

class Integer(Number) {
    const value: int;

    fn __new__(value: int) void {
        super.__new__();

        this.value = value;
    }

    @Override
    fn intValue() int {
        return this.value;
    }
}

/*
Documents for native functions.

#####
memory_segment(ptr: *void) int;

Returns the memory segment of this pointer is pointed to
-1: if invalid
0:  if null
1:  if in stack
2:  if in global memory
3:  if in literal
4:  if in class headers
5:  if in function bodies
6:  if in heap
*/

fn print(value: int) void {
    print_int(value);
}

fn println(value: int) void {
    println_int(value);
}

fn print(value: float) void {
    print_float(value);
}

fn println(value: float) void {
    println_float(value);
}

fn print(value: char) void {
    print_char(value);
}

fn println(value: char) void {
    println_char(value);
}

fn print(value: byte) void {
    print_byte(value);
}

fn println(value: byte) void {
    println_byte(value);
}

fn print(value: *String) void {
    value.print();
}

fn println(value: *String) void {
    value.println();
}

fn print(value: *Object) void {
    print(value.toString());
}

fn println(value: *Object) void {
    println(value.toString());
}

exportmacro {
    boolean
}

export {
    FALSE, TRUE, NULL, Object, String, Number, Integer, print, println
}
